<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <!-- * -->
  <h1>setTimeout() 동작을 취소하려면 5초 안에 버튼을 클릭하세요!!!</h1>
  <p>콘솔 패널을 열어 확인하세요.</p>
  <button type="button" onclick="clearTimeout(timer)">멈추기</button>
  
  <!-- ** -->
  <h1>일정 시간 간격으로 값 증감시키기</h1>
  <p>콘솔 패널을 열어 확인하세요.</p>
  <button type="button" onclick="clearInterval(counter)">증가 정지</button>
  <button type="button" onclick="clearInterval(miner)">감소 정지</button>
  
  <!-- *** -->
  <h1>리다이렉트 하기</h1>
  <button type="button" onclick="href()">Naver로 이동<br>(herf속성)</button>
  <button type="button" onclick="assign()">Naver로 이동<br>(assign() 메소드)</button>
  <button type="button" onclick="replace()">Naver로 이동<br>(replace() 메소드)</button>

  <!-- **** -->
  <h1>이전, 다음 페이지로 이동</h1>
  <button type="button" onclick="back()">뒤로가기</button>
  <button type="button" onclick="forward()">앞으로가기</button>

  
  <script>
    // 브라우저 객체 모델 browser object model(BOM)
    // 브라우저에 내장된 객체를 가리키고 브라우저를 제어 및 조작 가능
    // window: 브라우저 객체의 최상위 객체, 아래와 같은 하위 객체를 계층 구조로 포함 ★★★
    // - screen: 스크린 관련된 정보 제공(화면 정보)
    // - location: 현재 브라우저의 위치 정보(URL 정보) ★
    // - history: 브라우저에서 웹 서핑을 할 때 기록들을 가짐 ★
    // - navigator: OS, 브라우저에 대한 다양한 정보를 가짐 ★
    // - document(DOM): 문서 객체, 웹 문서 관련 ★★

    // 1. window 객체
    // 1) alert()
    // 경고창을 띄워 경고메세지를 출력
    //alert(`이것은 alert 창입니다`);

    // 2) confirm()
    // 확인창을 띄워 진행할지, 종료할지에 대한 진행 여부를 확인
    // 확인을 누르면 true를 반환, 취소를 누르면 false를 반환
    // if( confirm('정말 삭제하시겠습니까?')){
    //   console.log('삭제실행');
    // } else {
    //   document.write(`강조되고 반복되는 소리는🎙강아지를🐶 불안하게 해요‼️〰️ 🤷‍♀️네? 다시요. 🙅‍♂️ 강조되고 반복되는 소리는 강아지를 불~안하게 한다구욧🙅‍♂️ 🤷‍♀️그럼 잘했다고 하지 말라구여? 💁‍♂️네에!! 아니요!!! (짝짝짝) 이렇게는 좋은게 아니에요⤴️~!!! 🤷‍♀️ 오...진짜?? 🤷‍♂️네에~!!!! 🐶 왈왈왈 🤷‍♀️ 허허허 이런소리 싫어해요 🤷‍♂️네에~!!!! 맞아요!! 그런소리를 하고있어요! 🐶ㅡㅡ왈왈왈 🤷‍♂️어어~~~그래그래 미키미키 💁‍♂️ 일로와 🙋‍♂️ 어이! 🙋‍♂️어잇 🙋‍♂️ 어잇 (짝짝) 🙋‍♂️ 어잇!!!! (짝짝) 🙋‍♂️ 어잇 🤸‍♀️ 미키 🤸`);
    // }

    // 3) prompt()
    // 질의응답 창을 띄워 문자열을 입력받음
    // 확인을 누르면 입력한 값을 반혼
    // 취소를 누르면 null을 반환
    const txt = prompt('비밀번호를 입력하세요.');
    
    if (txt === null){
      console.log('취소버튼을 클릭했을 때');
      document.write(`[속보] 응~👌🏻 어쩔티비~ 📺💁🏻‍♂️ 저쩔티비~📺 💁🏻‍♀️ 안물티비~안궁티비~뇌절티비~우짤래미~ 저짤래미~ 쿠쿠루삥뽕🕺🏻 지금 화났죠?🔥😛 개킹받죠? 죽이고 싶죠? 🤗어차피 내가 사는곳 모르죠? 응~못 죽이죠?👊🏻🤟🏻 어~또 빡치죠? 😌아무것도 모르죠? 아무것도 못하죠?😉 그냥 화났죠? 냬~알걨섑니댸👏🏻🙃🙃`);
    } else if (txt === ''){
      console.log('어떤 값도 입력하지 않고 확인 버튼을 클릭했을때');
      document.write(`행복하다면 냐옹 하라는데 내가 할 것 같냐옹🐈밥 바꿨네,,이게 더 맛있다,,,🐈집사야..일하지말고 놀아줘라🐈집사야..일해서 그 돈을 나에게 써라🐈집사야..집에 새로운 인간 좀 데려와봐라🐈집사야..벌써 나무에 잎사귀가 자란다..🐈집사야..밖은 궁금한데 나가기가 싫다..🐈집사야..자주 창문 좀 열어놔라 밖 구경 좀하게🐈집사야..🐈집사야...일해라🐈집사야..밥줘라🐈집사야..물줘라🐈집사야..화장실청소해라🐈집사야..어디갔냐🐈집사야..놀아줘라🐈집사야..자게 냅둬라🐈집사야..애쓰네🐈집사야..건들지 마라🐈집사야..나 왜 안 보냐🐈집사야 어디가냐 🐈행복하다면 냐옹 하라는데 내가 할 것 같냐옹🐈밥 바꿨네,,이게 더 맛있다,,,🐈집사야..일하지말고 놀아줘라🐈집사야..일해서 그 돈을 나에게 써라🐈집사야..집에 새로운 인간 좀 데려와봐라🐈집사야..벌써 나무에 잎사귀가 자란다..🐈집사야..밖은 궁금한데 나가기가 싫다..🐈집사야..자주 창문 좀 열어놔라 밖 구경 좀하게🐈집사야..🐈집사야...일해라🐈집사야..밥줘라🐈집사야..물줘라🐈집사야..화장실청소해라🐈집사야..어디갔냐🐈집사야..놀아줘라🐈집사야..자게 냅둬라🐈집사야..애쓰네🐈집사야..건들지 마라🐈집사야..나 왜 안 보냐🐈집사야 어디가냐 🐈`);
    } else if (txt !== ''){
      console.log('값을 입력하고 확인 버튼을 눌렀을때');
      document.write(`너 겨드랑이털🧶 난 상관없어🙅 내가 털🧶을 얼마나 좋아하는데
      나는 🧢도 🧶🧢만 쓰고 그리고 나는 🥟도 🧶보🥟만 먹고
      그리고 나 굉장히 성격이 🧶🧶하다는 얘기도 되게 많이 들어💁‍♂️
      그리고 우리🏠 🖥 도 디지🧶이야
      내가 🧶을 얼마나 ❤️하는데~ 우와 🧶이다! 우와!~🤩
      아! 다시 시작하기에 앞서 난 너의 🧶들 에게 정식으로 🍎하고싶어.
      🧶들아~ 🧶들아~ 내 🐴들려? 내 ❤️ 희진이의 옆구리를 따스하게 댑혀주고있는 이 기특한 🧶들아. 곱게도 생겼구나. 무성히도 자랐구나.🌴
      `);
    }
    
    // 4) open()
    // 팝업창(브라우저 새 창/새 탭)을 띄워 지정한 url을 오픈
    // open('http://www.google.com');
    // open('http://www.google.com','googlewindow','popup');
    // open('http://www.google.com','googlewindow', 'width= 300, height=400, left=300, top=50','popup');

    // 5) setTimeout(), clearTimeout()
    // id = setTimeout(): 지정한 시간 뒤에 정의한 함수를 실행
    // clearTimeout(id): setTimeout()으로 설정된 타이머를 지움(위에 * 참조)
    const timer = setTimeout(()=>{
      console.log('5초 후 프로그램 실행');
    },5000);

    // 6) setInterval(), clearInterval()
    // id = setIntervla(): 지정한 시간 간격마다 정의한 함수를 반복적으로 실행
    // clearInterval(id): setInterval로 설정된 타이머를 지움(위에 ** 참조)
    let addNum = 0;
    let subNum = 1000;

    const counter = setInterval(()=>{
      addNum++;
      console.log(`addNum: ${addNum}`);
    },3000);

    const miner = setInterval(()=>{
      subNum--;
      console.log(`subNum: ${subNum}`);
    },3000);

    // 2. screen 객체
    // 사용자의 모니터(화면) 정보를 제공
    document.write('<h2>screen 관련 속성</h2>');
    document.write(screen.width,'<br>');
    document.write(screen.height,'<br>');
    document.write(screen.availWidth,'<br>');
    document.write(screen.availHeight,'<br>');

    // 3. location 객체
    // 현재 url과 관련된 속성과 메소드 제공
    document.write('<h2>location 관련 속성</h2><br>');
    document.write(`origin: ${location.origin} <br>`);
    document.write(`protocol: ${location.protocol}<br>`);
    document.write(`host: ${location.host}<br>`);
    document.write(`hostname: ${location.hostname}<br>`);
    document.write(`port: ${location.port}<br>`);
    document.write(`href: ${location.href}<br>`);
    document.write(`search: ${location.search}<br>`); // 쿼리 스트링
    // 이렇게 쿼리로 보내는 방식을 겟방식이라고 함, 보안에 취약 
    // 아이디와 패스워드같은 보안이 필요한 정보는 포스트 방식으로 보냄
    
    // location.reload(); // 새로고침

    // 리다이렉트하기 (위에 ***참조)
    // 다른 주소나 페이지로 보내기
    function  href() {
      // 현재 url을 설정
      location.href = 'http://www.naver.com';
    }
    function assign() {
      // 새 문서를 로드
      // 히스토리가 쌓임
      location.assign('http://www.naver.com');
    }
    function replace() {
      // 현재 문서를 새 문서로 교체
      // 히스토리에서 현재 URL 을 제거, 원래 문서로 back 불가
      location.replace('http://www.naver.com');
    }
    

    // 4. history 객체
    // 사용자가 방문한 사이트의 기록을 남기고, 이전과 다음 페이지로 다시 돌아갈 수 있도록 제공
    document.write('<h2>history 관련 속성</h2>');
    document.write('length: '+history.length); // 방문 기록에 저장된 url 개수

    // 이전, 다음 페이지로 이동
    // 브라우저 뒤로가기, 앞으로 가기와 동일 (위에 ****참조)

    function back(){
      // back forward go~
      history.back();
    }
    function forward() {
      history.forward();
    }

    // 5. navigator 객체
    // 현재 방문자가 사용하는 브라우저와 운영체제 정보를 제공
    document.write('<h2>navigator 관련 속성</h2>');
    document.write(`userAgent: ${navigator.userAgent}<br>`); // 브라우저 및 운영체제에 대한 종합 정보

    const info = navigator.userAgent.toLowerCase();
    let osImg = null;
    if (info.includes('windows')) {
      osImg = 'windows.png';
    } else if (info.includes('macintosh')) {
      osImg = 'macintosh.png';
    } else if (info.includes('iphone')) {
      osImg = 'iphone.png';
    } else if (info.includes('android')) {
      osImg = 'android.png';
    }
    document.write(`<img src="images/${osImg}">`);

    
    // Tip! 위치 정보(좌표) 가져오기 (위에 ***** 참조)
    // HTML Geolocation API는 사용자의 위치를 찾는 데 사용

    function geolocation(){
      if(navigator.geolocation){
        // getCurrentPosition(함수1,함수2,옵션) : 사용자의 위치를 반환
        // 함수1 -> 사용자의 정보를 가져오는데 성공했을때 실행되는 함수
        // 함수2 -> 사용자의 정보를 가져오는데 실패했을때 실행되는 함수
        // 옵션 -> 시간 설정 등
        navigator.geolocation.getCurrentPosition((position)=>{
          console.log(position);
          alert(`위도: ${position.coords.latitude}, 경도: ${position.coords.longitude}`);
        });
      } else {
        alert(`이 브라우저는 위치정보가 지원되지 않습니다.`);
      }
    }

    // (참고)
    // navigator.geolocation.watchPosition(); 사용자의 현재 위치를 반환하고, 사용자가 움직일 때마다 업데이트 된 위치를 계속 반환
    // navigator.geolocation.clearWatch(); watchPosition()을 취소

  </script>
</body>
</html>